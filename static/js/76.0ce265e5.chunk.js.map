{"version":3,"sources":["pages/EditPage/EditView/DropView.js"],"names":["calcIndex","pos","prev","insert","candidates","document","getElementsByClassName","index","box","getBoundingClientRect","Math","floor","y","x","left","width","top","bottom","right","cardDropTarget","hover","props","monitor","component","getClientOffset","setHoverIndex","drop","didDrop","cardDrop","containerRef","React","createRef","prevProps","isOver","this","isOverCurrent","children","connectDropTarget","Component","DropTarget","connect","dropTarget","canDrop"],"mappings":"iLAWMA,EAAY,SAASC,GACvB,IAIIC,EACAC,EANuB,EACvBC,EAAaC,SAASC,uBAAuB,iBAG7CC,EAAQ,EAJe,cAOXH,GAPW,IAO3B,IAAI,EAAJ,qBAA2B,CAAC,IACpBI,EADmB,QACRC,wBACf,GAAa,IAAVF,GAAeG,KAAKC,MAAMH,EAAII,KAAOF,KAAKC,MAAMT,EAAKU,GAAG,CACvD,GAAGX,EAAIY,GAAKL,EAAIM,KAAON,EAAIO,MAAM,GAAKd,EAAIY,GAAKL,EAAIM,KAP1C,IAO6Db,EAAIW,GAAKJ,EAAIQ,KAAOf,EAAIW,GAAKJ,EAAIS,OACnG,MAAO,CAAEd,OAAQI,GAErB,GAAa,IAAVA,GAAeN,EAAIW,GAAKJ,EAAIQ,IAVtB,IAUwCf,EAAIW,EAAIJ,EAAIQ,IACzD,MAAO,CAAEb,OAAQI,GAErB,GAAGL,GAAQD,EAAIW,EAAIV,EAAKe,QAAUhB,EAAIW,EAAIJ,EAAIQ,IAC1C,MAAO,CAAEb,OAAQI,GAErB,GAAGL,GAAQD,EAAIY,GAAKX,EAAKgB,MAhBhB,IAgBoCjB,EAAIY,GAAKX,EAAKgB,MAAQhB,EAAKa,MAAM,GAAKd,EAAIW,GAAKV,EAAKc,KAAOf,EAAIW,GAAKV,EAAKe,OAClH,MAAO,CAAEd,OAAQI,QAGrB,GAAGN,EAAIY,GAAKL,EAAIM,KAAON,EAAIO,MAAM,GAAKd,EAAIY,GAAKX,EAAKgB,MAAQhB,EAAKa,MAAM,GAAKd,EAAIW,GAAKJ,EAAIQ,KAAOf,EAAIW,GAAKJ,EAAIS,OACzG,MAAO,CAAEd,OAAQI,GAGzBA,IACAL,EAAOM,GA5BgB,8BA8B3B,OAAIN,IAEAC,GAAUD,GAAQD,EAAIY,GAAKX,EAAKgB,MA7BnB,IA6BuCjB,EAAIY,GAAKX,EAAKgB,MAAQhB,EAAKa,MAAM,GAAKd,EAAIW,GAAKV,EAAKc,KAAOf,EAAIW,GAAKV,EAAKe,SAC7Hd,EAASI,GAEVN,EAAIW,EAAIV,EAAKe,QAAUhB,EAAIW,GAAKV,EAAKe,OAhCvB,KAiCbd,EAASI,GAGN,CAAEJ,OAAQA,IATA,CAACA,OAAO,IAevBgB,EAAiB,CACnBC,MADmB,SACbC,EAAOC,EAASC,GAelB,IAAItB,EAAMqB,EAAQE,kBAClBD,EAAUF,MAAMI,cAAczB,EAAUC,GAAKE,SAGjDuB,KApBmB,SAoBdL,EAAOC,EAASC,GACjB,IAAID,EAAQK,UAAZ,CAOAJ,EAAUF,MAAMI,eAAe,GAC/B,IAAIxB,EAAMqB,EAAQE,kBAClB,OAAOxB,EAAUC,M,IAoBnB2B,E,kDACF,WAAYP,GAAQ,IAAD,8BACf,cAAMA,IACDQ,aAAeC,IAAMC,YAFX,E,sDAKnB,SAAmBC,IACVA,EAAUC,QAAUC,KAAKb,MAAMY,OAIhCD,EAAUC,QAAWC,KAAKb,MAAMY,OAIhCD,EAAUG,eAAkBD,KAAKb,MAAMc,gB,oBAM/C,WAEI,IAAQC,EAAaF,KAAKb,MAAlBe,SAIAC,EAAsBH,KAAKb,MAA3BgB,kBACR,OAAOA,GAAqBA,EACxBD,O,GA7BWN,IAAMQ,WAkCdC,+BApIL,OAsIRpB,GAjDF,SAAiBqB,EAASlB,GACxB,MAAO,CAGLe,kBAAmBG,EAAQC,aAE3BR,OAAQX,EAAQW,SAEhBS,QAASpB,EAAQoB,aAuCNH,CAIbX","file":"static/js/76.0ce265e5.chunk.js","sourcesContent":["import React from 'react'\nimport { DropTarget } from 'react-dnd'\n\n// Drag sources and drop targets only interact\n// if they have the same string type.\n// You want to keep types in a separate file with\n// the rest of your app's constants.\nconst Types = {\n    CARD: 'card'\n}\n\nconst calcIndex = function(pos){\n    let candidates = document.getElementsByClassName(\"factsheetSlot\");\n        \n    const boderGap = 60;\n    let index = 0;\n    let prev;\n    let insert;\n    for(let slot of candidates){\n        let box = slot.getBoundingClientRect();\n        if(index === 0 || Math.floor(box.y) !== Math.floor(prev.y)){//first one in one row \n            if(pos.x <= box.left + box.width/2 && pos.x >= box.left - boderGap && pos.y >= box.top && pos.y <= box.bottom){\n                return { insert: index }\n            }\n            if(index === 0 && pos.y >= box.top - boderGap && pos.y < box.top){//title\n                return { insert: index }\n            }\n            if(prev && pos.y > prev.bottom && pos.y < box.top){//between row\n                return { insert: index }\n            }\n            if(prev && pos.x <= prev.right + boderGap && pos.x >= prev.right - prev.width/2 && pos.y >= prev.top && pos.y <= prev.bottom){//last one in one row\n                return { insert: index }\n            }\n        }else{\n            if(pos.x <= box.left + box.width/2 && pos.x >= prev.right - prev.width/2 && pos.y >= box.top && pos.y <= box.bottom){\n                return { insert: index }\n            }\n        }\n        index ++;\n        prev = box;\n    }\n    if(!prev) return {insert:0}\n    //last one\n    if(!insert && prev && pos.x <= prev.right + boderGap && pos.x >= prev.right - prev.width/2 && pos.y >= prev.top && pos.y <= prev.bottom){\n        insert = index;\n    }\n    if(pos.y > prev.bottom && pos.y <= prev.bottom + boderGap){\n        insert = index;\n    }\n\n    return { insert: insert }\n}\n/**\n * Specifies the drop target contract.\n * All methods are optional.\n */\nconst cardDropTarget = {\n    hover(props, monitor, component) {\n        // This is fired very often and lets you perform side effects\n        // in response to the hover. You can't handle enter and leave\n        // hereâ€”if you need them, put monitor.isOver() into collect() so you\n        // can use componentDidUpdate() to handle enter/leave.\n\n        // You can access the coordinates if you need them\n        // const clientOffset = monitor.getClientOffset()\n        // const componentRect = findDOMNode(component).getBoundingClientRect()\n\n        // // You can check whether we're over a nested drop target\n        // const isOnlyThisOne = monitor.isOver({ shallow: true })\n\n        // // You will receive hover() even for items for which canDrop() is false\n        // const canDrop = monitor.canDrop()\n        let pos = monitor.getClientOffset();\n        component.props.setHoverIndex(calcIndex(pos).insert);\n    },\n\n    drop(props, monitor, component) {\n        if (monitor.didDrop()) {\n            // If you want, you can check whether some nested\n            // target already handled drop\n            return\n        }\n\n        // Obtain the dragged item\n        component.props.setHoverIndex(-1);\n        let pos = monitor.getClientOffset();\n        return calcIndex(pos);\n    }\n}\n\n/**\n * Specifies which props to inject into your component.\n */\nfunction collect(connect, monitor) {\n  return {\n    // Call this function inside render()\n    // to let React DnD handle the drag events:\n    connectDropTarget: connect.dropTarget(),\n    // You can ask the monitor about the current drag state:\n    isOver: monitor.isOver(),\n    // isOverCurrent: monitor.isOver({ shallow: true }),\n    canDrop: monitor.canDrop(),\n    // itemType: monitor.getItemType()\n  }\n}\n\nclass cardDrop extends React.Component{\n    constructor(props) {\n        super(props);\n        this.containerRef = React.createRef()\n    }\n\n    componentDidUpdate(prevProps) {\n        if (!prevProps.isOver && this.props.isOver) {\n        // You can use this as enter handler\n        }\n\n        if (prevProps.isOver && !this.props.isOver) {\n        // You can use this as leave handler\n        }\n\n        if (prevProps.isOverCurrent && !this.props.isOverCurrent) {\n        // You can be more specific and track enter/leave\n        // shallowly, not including nested targets\n        }\n    }\n\n    render() {\n        // Your component receives its own props as usual\n        const { children } = this.props\n\n        // These props are injected by React DnD,\n        // as defined by your `collect` function above:\n        const { connectDropTarget } = this.props\n        return connectDropTarget && connectDropTarget(\n            children\n        )\n    }\n}\n\nexport default DropTarget(\n  Types.CARD,\n  cardDropTarget,\n  collect\n)(cardDrop)\n"],"sourceRoot":""}