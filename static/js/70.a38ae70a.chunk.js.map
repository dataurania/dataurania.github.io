{"version":3,"sources":["pages/EditPage/EditDataVideos/Fact/helper.js"],"names":["getMaxRows","rawData","encoding","d3","key","d","x","field","entries","map","i","index","values","a","b","y","getAggregatedRows","data","aggregation","calculateData","sumData","Array","length","fill","forEach","sumRows","Object","assign","getSumRows","getAverageRows","getMinRows","countData","countRows","getCountRows"],"mappings":"yGAAA,yHAEA,IA8BMA,EAAa,SAACC,EAASC,GAazB,OAZoBC,SAAUC,KAAI,SAAAC,GAAC,OAAIA,EAAEH,EAASI,EAAEC,UAAQC,QAAQP,GAC3CQ,KAAI,SAAUJ,EAAGK,GACtC,IAAIC,EAAQR,OAAQE,EAAEO,QAAQ,SAAUC,EAAGC,GACvC,GAAID,EAAEX,EAASa,EAAER,QAAUO,EAAEZ,EAASa,EAAER,OACpC,OAAOO,EAAEZ,EAASa,EAAER,OAASM,EAAEX,EAASa,EAAER,UAElD,OAAII,GAAS,EACFN,EAAEO,OAAOD,GAETN,EAAEO,OAAO,OAkCtBI,EAAoB,SAACf,EAASC,GAChC,IAAIe,EACJ,OAAQf,EAASa,EAAEG,aACf,IAAK,MACDD,EAhCO,SAAChB,EAASC,GACzB,IAAIiB,EAAgBhB,SAAUC,KAAI,SAAAC,GAAC,OAAIA,EAAEH,EAASI,EAAEC,UAAQC,QAAQP,GAChEmB,EAAU,IAAIC,MAAMF,EAAcG,QAAQC,KAAK,GASnD,OARWJ,EAAcV,KAAI,SAAUJ,EAAGK,GACtCL,EAAEO,OAAOY,SAAQ,SAAAnB,GACbe,EAAQV,IAAML,EAAEH,EAASa,EAAER,UAE/B,IAAIkB,EAAUC,OAAOC,OAAO,GAAItB,EAAEO,OAAO,IAEzC,OADAa,EAAQvB,EAASa,EAAER,OAASa,EAAQV,GAC7Be,KAuBIG,CAAW3B,EAASC,GAC3B,MACJ,IAAK,MACDe,EArBW,SAAChB,EAASC,GAC7B,IAAIiB,EAAgBhB,SAAUC,KAAI,SAAAC,GAAC,OAAIA,EAAEH,EAASI,EAAEC,UAAQC,QAAQP,GAChEmB,EAAU,IAAIC,MAAMF,EAAcG,QAAQC,KAAK,GASnD,OARWJ,EAAcV,KAAI,SAAUJ,EAAGK,GACtCL,EAAEO,OAAOY,SAAQ,SAAAnB,GACbe,EAAQV,IAAML,EAAEH,EAASa,EAAER,UAE/B,IAAIkB,EAAUC,OAAOC,OAAO,GAAItB,EAAEO,OAAO,IAEzC,OADAa,EAAQvB,EAASa,EAAER,OAASa,EAAQV,GAAKL,EAAEO,OAAOU,OAC3CG,KAYII,CAAe5B,EAASC,GAC/B,MACJ,IAAK,MACDe,EAAOjB,EAAWC,EAASC,GAC3B,MACJ,IAAK,MACDe,EAzEO,SAAChB,EAASC,GAazB,OAZoBC,SAAUC,KAAI,SAAAC,GAAC,OAAIA,EAAEH,EAASI,EAAEC,UAAQC,QAAQP,GAC3CQ,KAAI,SAAUJ,GACnC,IAAIM,EAAQR,OAAQE,EAAEO,QAAQ,SAAUC,EAAGC,GACvC,GAAID,EAAEX,EAASa,EAAER,QAAUO,EAAEZ,EAASa,EAAER,OACpC,OAAOM,EAAEX,EAASa,EAAER,OAASO,EAAEZ,EAASa,EAAER,UAElD,OAAII,GAAS,EACFN,EAAEO,OAAOD,GAETN,EAAEO,OAAO,MA+DTkB,CAAW7B,EAASC,GAC3B,MACJ,IAAK,QACDe,EA1FS,SAAChB,EAASC,GAC3B,IAAIiB,EAAgBhB,SAAUC,KAAI,SAAAC,GAAC,OAAIA,EAAEH,EAASI,EAAEC,UAAQC,QAAQP,GAChE8B,EAAY,IAAIV,MAAMF,EAAcG,QAAQC,KAAK,GASrD,OARWJ,EAAcV,KAAI,SAAUJ,EAAGK,GACtCL,EAAEO,OAAOY,SAAQ,WACbO,EAAUrB,IAAM,KAEpB,IAAIsB,EAAYN,OAAOC,OAAO,GAAItB,EAAEO,OAAO,IAE3C,OADAoB,EAAS,MAAYD,EAAUrB,GACxBsB,KAiFIC,CAAahC,EAASC,GAC7B,MAEJ,QACIe,EAAOjB,EAAWC,EAASC,GAGnC,OAAOe","file":"static/js/70.a38ae70a.chunk.js","sourcesContent":["import * as d3 from 'd3';\nimport datafilter from '../../../../../src/tool/datafilter'\nconst getCountRows = (rawData, encoding) => {\n    let calculateData = d3.nest().key(d => d[encoding.x.field]).entries(rawData);\n    let countData = new Array(calculateData.length).fill(0);\n    let data = calculateData.map(function (d, i) {\n        d.values.forEach(() => {\n            countData[i] += 1\n        })\n        let countRows = Object.assign({}, d.values[0])\n        countRows['COUNT'] = countData[i]\n        return countRows\n    });\n    return data;\n}\n\nconst getMinRows = (rawData, encoding) => {\n    let calculateData = d3.nest().key(d => d[encoding.x.field]).entries(rawData);\n    let data = calculateData.map(function (d) {\n        let index = d3.scan(d.values, function (a, b) {\n            if (a[encoding.y.field] && b[encoding.y.field])\n                return a[encoding.y.field] - b[encoding.y.field];\n        });\n        if (index >= 0) {\n            return d.values[index]\n        } else {\n            return d.values[0]\n        }\n    });\n    return data;\n}\n\nconst getMaxRows = (rawData, encoding) => {\n    let calculateData = d3.nest().key(d => d[encoding.x.field]).entries(rawData);\n    let data = calculateData.map(function (d, i) {\n        let index = d3.scan(d.values, function (a, b) {\n            if (a[encoding.y.field] && b[encoding.y.field])\n                return b[encoding.y.field] - a[encoding.y.field];\n        });\n        if (index >= 0) {\n            return d.values[index]\n        } else {\n            return d.values[0];\n        }\n    });\n    return data;\n}\n\nconst getSumRows = (rawData, encoding) => {\n    let calculateData = d3.nest().key(d => d[encoding.x.field]).entries(rawData);\n    let sumData = new Array(calculateData.length).fill(0);\n    let data = calculateData.map(function (d, i) {\n        d.values.forEach(d => {\n            sumData[i] += d[encoding.y.field]\n        })\n        let sumRows = Object.assign({}, d.values[0])\n        sumRows[encoding.y.field] = sumData[i]\n        return sumRows\n    });\n    return data;\n}\n\nconst getAverageRows = (rawData, encoding) => {\n    let calculateData = d3.nest().key(d => d[encoding.x.field]).entries(rawData);\n    let sumData = new Array(calculateData.length).fill(0);\n    let data = calculateData.map(function (d, i) {\n        d.values.forEach(d => {\n            sumData[i] += d[encoding.y.field]\n        })\n        let sumRows = Object.assign({}, d.values[0])\n        sumRows[encoding.y.field] = sumData[i] / d.values.length;\n        return sumRows;\n    });\n    return data;\n}\n\nconst getAggregatedRows = (rawData, encoding) => {\n    let data;\n    switch (encoding.y.aggregation) {\n        case 'sum':\n            data = getSumRows(rawData, encoding);\n            break;\n        case 'avg':\n            data = getAverageRows(rawData, encoding);\n            break;\n        case 'max':\n            data = getMaxRows(rawData, encoding);\n            break;\n        case 'min':\n            data = getMinRows(rawData, encoding);\n            break;\n        case 'count':\n            data = getCountRows(rawData, encoding)\n            break;\n\n        default:\n            data = getMaxRows(rawData, encoding);\n            break;\n    }\n    return data;\n}\n\nexport { getAggregatedRows, datafilter };"],"sourceRoot":""}